# -*- coding: utf-8 -*-
"""
Release Composer â€” Ð²Ñ‹Ð³Ñ€ÑƒÐ·ÐºÐ° ÑÐ¾ÑÑ‚Ð°Ð²Ð° Ñ€ÐµÐ»Ð¸Ð·Ð¾Ð² Ð¿Ð¾ ÐºÐ¾Ð´Ñƒ Ð¿Ñ€Ð¾ÐµÐºÑ‚Ð° JIRA
(ÑÐ¿Ð¸ÐºÐ¸ â†’ Ð¸ÑÑ‚Ð¾Ñ€Ð¸Ð¸/Ð·Ð°Ð´Ð°Ñ‡Ð¸ â†’ ÑÐ°Ð±Ñ‚Ð°ÑÐºÐ¸) + ÑÐ²ÑÐ·Ð¸ Ð·Ð°Ð´Ð°Ñ‡ â†’ Excel Ñ Ð¸ÐµÑ€Ð°Ñ€Ñ…Ð¸ÐµÐ¹ Ð¸ Ð±Ð°Ð·Ð¾Ð²Ð¾Ð¹ Ð²Ð¸Ð·ÑƒÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸ÐµÐ¹.

âš™ï¸ ÐŸÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ðµ Ð¾ÐºÑ€ÑƒÐ¶ÐµÐ½Ð¸Ñ (Ð¸Ð»Ð¸ Ð·Ð°Ð´Ð°Ð¹Ñ‚Ðµ Ð¿Ñ€ÑÐ¼Ð¾ Ð² ÐºÐ¾Ð´Ðµ Ð½Ð¸Ð¶Ðµ):
- JIRA_URL            â€” Ð±Ð°Ð·Ð¾Ð²Ñ‹Ð¹ URL Ð²Ð°ÑˆÐµÐ¹ Jira (Ð½Ð°Ð¿Ñ€Ð¸Ð¼ÐµÑ€, https://jira.nlmk.com)
- JIRA_BEARER_TOKEN   â€” Bearer-Ñ‚Ð¾ÐºÐµÐ½ (Ñ‚Ð¾Ñ‚ Ð¶Ðµ, Ñ‡Ñ‚Ð¾ Ð² Worklog_with_summary_labels.py)
- PROJECT_KEY         â€” ÐºÐ»ÑŽÑ‡ Ð¿Ñ€Ð¾ÐµÐºÑ‚Ð° (Ð½Ð°Ð¿Ñ€Ð¸Ð¼ÐµÑ€, "CSHRM")
- VERSIONS_FILTER     â€” ÑÐ¿Ð¸ÑÐ¾Ðº Ð²ÐµÑ€ÑÐ¸Ð¹ Ñ‡ÐµÑ€ÐµÐ· Ð·Ð°Ð¿ÑÑ‚ÑƒÑŽ (Ð¸Ð¼ÐµÐ½Ð° Ñ€ÐµÐ»Ð¸Ð·Ð¾Ð² Fix Version), ÐµÑÐ»Ð¸ Ð¿ÑƒÑÑ‚Ð¾ â€” Ð²ÑÐµ Ð°ÐºÑ‚Ð¸Ð²Ð½Ñ‹Ðµ
- ONLY_UNRELEASED     â€” "1" â†’ Ð±Ñ€Ð°Ñ‚ÑŒ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ unreleased Ð²ÐµÑ€ÑÐ¸Ð¸; "0" â†’ Ð²ÑÐµ (Ð¿Ð¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ "1")
- MAX_ISSUES          â€” Ð·Ð°Ñ‰Ð¸Ñ‚Ð½Ñ‹Ð¹ Ð»Ð¸Ð¼Ð¸Ñ‚ Ð·Ð°Ð´Ð°Ñ‡ Ð½Ð° Ð¾Ð´Ð½Ñƒ Ð²ÐµÑ€ÑÐ¸ÑŽ (Ð¿Ð¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ 5000)

ðŸ“¦ Ð’Ñ‹Ñ…Ð¾Ð´Ð½Ð¾Ð¹ Excel Ð²ÐºÐ»ÑŽÑ‡Ð°ÐµÑ‚ Ð»Ð¸ÑÑ‚Ñ‹:
- Overview         â€” ÑÐ²Ð¾Ð´ÐºÐ° Ð¿Ð¾ Ñ€ÐµÐ»Ð¸Ð·Ð°Ð¼: ÐºÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾ Ð·Ð°Ð´Ð°Ñ‡ Ð¿Ð¾ Ñ‚Ð¸Ð¿Ð°Ð¼/ÑÑ‚Ð°Ñ‚ÑƒÑÐ°Ð¼
- Release_Tree     â€” Ð¸ÐµÑ€Ð°Ñ€Ñ…Ð¸Ñ: Release â†’ Epic â†’ Issue â†’ Sub-task (Ñ Ð³Ñ€ÑƒÐ¿Ð¿Ð¸Ñ€Ð¾Ð²ÐºÐ¾Ð¹ ÑÑ‚Ñ€Ð¾Ðº Ð¸ HYPERLINK)
- Relationships    â€” ÑÐ¿Ð¸ÑÐ¾Ðº ÑÐ²ÑÐ·ÐµÐ¹ Ð·Ð°Ð´Ð°Ñ‡ (blocks/relates/duplicates/â€¦)

ðŸ§© ÐžÑÐ¾Ð±ÐµÐ½Ð½Ð¾ÑÑ‚Ð¸:
- ÐÐ²Ñ‚Ð¾Ð¼Ð°Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¸Ð¹ Ð¿Ð¾Ð¸ÑÐº id ÐºÐ°ÑÑ‚Ð¾Ð¼-Ð¿Ð¾Ð»ÐµÐ¹ "Epic Link" Ð¸ "Story Points".
- Ð˜ÐµÑ€Ð°Ñ€Ñ…Ð¸Ñ ÑÑ‚Ñ€Ð¾Ð¸Ñ‚ÑÑ Ð¿Ð¾ Ð¿Ð¾Ð»ÑÐ¼ parent, subtasks Ð¸ epic link; Ð·Ð°Ð´Ð°Ñ‡Ð¸ Ð±ÐµÐ· ÑÐ¿Ð¸ÐºÐ° Ð²Ñ‹Ð²Ð¾Ð´ÑÑ‚ÑÑ Ð¿Ð¾Ð´ Â«(Ð±ÐµÐ· ÑÐ¿Ð¸ÐºÐ°)Â».
- Ð’ ÑÑ‚Ð¾Ð»Ð±Ñ†Ðµ Â«ÐÐ¾Ð´Ð°Â» Ð´Ð¾Ð±Ð°Ð²Ð»ÑÐµÑ‚ÑÑ Ð²Ð¸Ð·ÑƒÐ°Ð»ÑŒÐ½Ñ‹Ð¹ Ð¾Ñ‚ÑÑ‚ÑƒÐ¿ Ð¿Ð¾ ÑƒÑ€Ð¾Ð²Ð½ÑŽ (Ð´Ð»Ñ ÑƒÐ´Ð¾Ð±Ð½Ð¾Ð³Ð¾ Ñ‡Ñ‚ÐµÐ½Ð¸Ñ Ð´Ð°Ð¶Ðµ Ð±ÐµÐ· Ð³Ñ€ÑƒÐ¿Ð¿Ð¸Ñ€Ð¾Ð²ÐºÐ¸).
- Ð’ÐºÐ»ÑŽÑ‡Ñ‘Ð½ Â«ÑƒÐ¼Ð½Ñ‹Ð¹Â» Ð°Ð²Ñ‚Ð¾Ñ„Ð¸Ñ‚ ÑˆÐ¸Ñ€Ð¸Ð½Ñ‹ ÐºÐ¾Ð»Ð¾Ð½Ð¾Ðº.

Ð—Ð°Ð²Ð¸ÑÐ¸Ð¼Ð¾ÑÑ‚Ð¸: requests, pandas, openpyxl
"""

import os, re, time, json, math
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Tuple

import pandas as pd
import requests

# ========= ENV =========

def _env(key: str, default: Optional[str] = None) -> str:
    """Ð‘ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾Ðµ Ñ‡Ñ‚ÐµÐ½Ð¸Ðµ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ñ… Ð¾ÐºÑ€ÑƒÐ¶ÐµÐ½Ð¸Ñ Ñ Ð·Ð°Ñ‰Ð¸Ñ‚Ð¾Ð¹ Ð¾Ñ‚ Ð¿ÑƒÑÑ‚Ñ‹Ñ…/"None"/Ð´ÐµÑ„Ð¸ÑÐ¾Ð²."""
    val = os.getenv(key)
    if val is None:
        return default or ""
    val = str(val).strip()
    if val.lower() in {"none", "null", "", "-", "â€”", "â€“"}:
        return default or ""
    return val

JIRA_URL          = _env("JIRA_URL", "https://jira.nlmk.com").rstrip("/")
JIRA_BEARER_TOKEN = _env("JIRA_BEARER_TOKEN", _env("JIRA_TEMPO_TOKEN", ""))
PROJECT_KEY       = _env("PROJECT_KEY", "CSHRM")
VERSIONS_FILTER   = [v.strip() for v in _env("VERSIONS_FILTER", "").split(",") if v.strip()]
ONLY_UNRELEASED   = _env("ONLY_UNRELEASED", "1") == "1"
MAX_ISSUES        = int(_env("MAX_ISSUES", "5000"))
ENABLE_LINK_HIERARCHY = _env("ENABLE_LINK_HIERARCHY", "1") == "1"

if not PROJECT_KEY:
    raise SystemExit("PROJECT_KEY Ð½Ðµ Ð·Ð°Ð´Ð°Ð½. Ð£ÐºÐ°Ð¶Ð¸ ÐºÐ»ÑŽÑ‡ Ð¿Ñ€Ð¾ÐµÐºÑ‚Ð°, Ð½Ð°Ð¿Ñ€Ð¸Ð¼ÐµÑ€ PROJECT_KEY=CSHRM")

if not JIRA_BEARER_TOKEN:
    raise SystemExit("ENV JIRA_BEARER_TOKEN/JIRA_TEMPO_TOKEN Ð½Ðµ Ð·Ð°Ð´Ð°Ð½ â€” Ð½ÑƒÐ¶ÐµÐ½ Bearer Ñ‚Ð¾ÐºÐµÐ½ Jira.")

HEADERS = {
    "Authorization": f"Bearer {JIRA_BEARER_TOKEN}",
    "Accept": "application/json",
    "Content-Type": "application/json",
}

# ========= ÐŸÐÐŸÐšÐ˜ Ð’Ð«Ð¥ÐžÐ”Ð =========
OUT_DIR = Path.cwd() / "release_export"
OUT_DIR.mkdir(parents=True, exist_ok=True)

# ========= Ð£Ñ‚Ð¸Ð»Ð¸Ñ‚Ñ‹ Excel =========
from openpyxl import load_workbook
from openpyxl.utils import get_column_letter
from openpyxl.worksheet.worksheet import Worksheet

# Ð˜Ð¼Ñ Ð»Ð¸ÑÑ‚Ð° Excel Ð¼Ð°ÐºÑÐ¸Ð¼ÑƒÐ¼ 31 ÑÐ¸Ð¼Ð²Ð¾Ð»
# ÐŸÑ€Ð¸Ð¼ÐµÑ€: make_sheet_name("CSHRM 2025.10", "Tree") â†’ "CSHRM 2025.10_Tree" (ÑƒÑÐµÑ‡Ñ‘Ñ‚ Ð±Ð°Ð·Ñƒ Ð¿Ñ€Ð¸ Ð½ÐµÐ¾Ð±Ñ…Ð¾Ð´Ð¸Ð¼Ð¾ÑÑ‚Ð¸)
def make_sheet_name(base: str, suffix: str) -> str:
    safe = re.sub(r'[:\/?*\[\]]', '_', str(base or 'Release'))
    max_base = 31 - (len(suffix) + 1)  # +1 Ð¿Ð¾Ð´ Ð¿Ð¾Ð´Ñ‡Ñ‘Ñ€ÐºÐ¸Ð²Ð°Ð½Ð¸Ðµ
    if max_base < 1:
        max_base = 1
    safe = safe[:max_base]
    return f"{safe}_{suffix}"

def _visible_text(val: object) -> str:
    if val is None:
        return ""
    s = str(val)
    if not s.startswith("="):
        return s
    m = re.match(r'^\s*=\s*HYPERLINK\s*\(\s*"[^"]*"\s*[,;]\s*"([^"]*)"\s*\)\s*$', s, re.IGNORECASE)
    return m.group(1) if m else s

def excel_autofit_smart(path: Path, width_overrides: Optional[Dict[str,int]] = None,
                        clamp_min: int = 6, clamp_max: int = 60):
    try:
        wb = load_workbook(path)
        for ws in wb.worksheets:
            headers = {cell.column: (cell.value or "") for cell in ws[1]}
            for col_cells in ws.columns:
                col_idx = col_cells[0].column
                head = str(headers.get(col_idx, "")).strip()
                if width_overrides and head in width_overrides:
                    ws.column_dimensions[get_column_letter(col_idx)].width = width_overrides[head]
                    continue
                max_len = max(len(_visible_text(c.value)) if c.value is not None else 0 for c in col_cells)
                max_len = max(max_len, len(head))
                ws.column_dimensions[get_column_letter(col_idx)].width = max(clamp_min, min(max_len + 2, clamp_max))
        wb.save(path)
    except Exception as e:
        print(f"[autofit] Ð¿Ñ€Ð¾Ð¿ÑƒÑ‰ÐµÐ½Ð¾: {e}")

# ========= Jira helpers =========

def hyperlink_formula(key: str) -> str:
    if not key:
        return ""
    k = str(key).strip().replace('"', '""')
    return f'=HYPERLINK("{JIRA_URL}/browse/{k}","{k}")'

SESSION = requests.Session()
SESSION.headers.update(HEADERS)


def jira_get(url: str, params: Optional[dict] = None) -> dict:
    r = SESSION.get(url, params=params, timeout=60)
    if r.status_code != 200:
        raise RuntimeError(f"GET {url} â†’ {r.status_code}: {r.text[:500]}")
    return r.json()


def jira_post(url: str, payload: dict) -> dict:
    r = SESSION.post(url, json=payload, timeout=120)
    if r.status_code != 200:
        raise RuntimeError(f"POST {url} â†’ {r.status_code}: {r.text[:500]}")
    return r.json()


def get_field_ids() -> Dict[str, str]:
    """Ð’Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÑ‚ id ÐºÐ°ÑÑ‚Ð¾Ð¼-Ð¿Ð¾Ð»ÐµÐ¹ Ð´Ð»Ñ Epic Link Ð¸ Story Points."""
    fields = jira_get(f"{JIRA_URL}/rest/api/2/field")
    epic_link_id = None
    story_points_id = None
    for f in fields:
        name = (f.get("name") or "").strip().lower()
        fid = f.get("id")
        if name == "epic link":
            epic_link_id = fid
        if name == "story points":
            story_points_id = fid
    return {"epic_link": epic_link_id, "story_points": story_points_id}


def list_versions(project_key: str) -> List[dict]:
    if not project_key or str(project_key).strip().lower() in {"none", "null", "-", "â€”", "â€“"}:
        raise SystemExit("list_versions: Ð¿ÑƒÑÑ‚Ð¾Ð¹ PROJECT_KEY â€” Ð·Ð°Ð´Ð°Ð¹ PROJECT_KEY=CSHRM (Ð¸Ð»Ð¸ ÑÐ²Ð¾Ð¹)")
    versions = jira_get(f"{JIRA_URL}/rest/api/2/project/{project_key}/versions")
    out = []
    for v in versions:
        if VERSIONS_FILTER and v.get("name") not in VERSIONS_FILTER:
            continue
        if ONLY_UNRELEASED and v.get("released"):
            continue
        if v.get("archived"):
            continue
        out.append({
            "id": v.get("id"),
            "name": v.get("name"),
            "released": v.get("released"),
            "releaseDate": v.get("releaseDate"),
            "overdue": v.get("overdue"),
        })
    out.sort(key=lambda x: (x.get("releaseDate") is None, x.get("releaseDate") or "9999-12-31", str(x.get("name") or "")))
    if not out:
        print("[warn] Ð’ÐµÑ€ÑÐ¸Ð¸ Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½Ñ‹ Ð¿Ð¾ Ð·Ð°Ð´Ð°Ð½Ð½Ñ‹Ð¼ Ñ„Ð¸Ð»ÑŒÑ‚Ñ€Ð°Ð¼. ÐŸÐ¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹ ÑÐ½ÑÑ‚ÑŒ ONLY_UNRELEASED Ð¸Ð»Ð¸ Ð·Ð°Ð´Ð°Ñ‚ÑŒ VERSIONS_FILTER.")
    return out


def jql_search(jql: str, fields: List[str], max_results: int = 1000) -> List[dict]:
    url = f"{JIRA_URL}/rest/api/2/search"
    start_at = 0
    issues: List[dict] = []
    while True:
        payload = {
            "jql": jql,
            "startAt": start_at,
            "maxResults": min(100, max_results - start_at),
            "fields": fields,
        }
        data = jira_post(url, payload)
        issues.extend(data.get("issues", []))
        start_at += len(data.get("issues", []))
        if start_at >= data.get("total", 0) or start_at >= max_results:
            break
    return issues

# ========= ÐŸÐ¾ÑÑ‚Ñ€Ð¾ÐµÐ½Ð¸Ðµ Ð¸ÐµÑ€Ð°Ñ€Ñ…Ð¸Ð¸ =========

# ÐŸÑ€Ð°Ð²Ð¸Ð»Ð° "Ð²Ð¸Ñ€Ñ‚ÑƒÐ°Ð»ÑŒÐ½Ð¾Ð¹" Ð¸ÐµÑ€Ð°Ñ€Ñ…Ð¸Ð¸ Ð¿Ð¾ ÑÑÑ‹Ð»ÐºÐ°Ð¼: parent_type â†’ child_type (case-insensitive)
LINK_HIERARCHY_RULES = [
    ("engineering concept", "change request"),
    ("support", "bugfix"),
]


def flatten_release_tree(release_name: str, issues: List[dict], epic_link_field: Optional[str]) -> Tuple[pd.DataFrame, pd.DataFrame]:
    """Ð¡Ñ‚Ñ€Ð¾Ð¸Ñ‚ Ð¸ÐµÑ€Ð°Ñ€Ñ…Ð¸ÑŽ Ð¸ Ñ‚Ð°Ð±Ð»Ð¸Ñ†Ñƒ ÑÐ²ÑÐ·ÐµÐ¹ Ð´Ð»Ñ Ð·Ð°Ð´Ð°Ð½Ð½Ð¾Ð³Ð¾ Ñ€ÐµÐ»Ð¸Ð·Ð°.
    Ð”Ð¾Ð¿Ð¾Ð»Ð½Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾: ÐµÑÐ»Ð¸ ENABLE_LINK_HIERARCHY=1 â€” ÑÐ¾Ð·Ð´Ð°Ñ‘Ñ‚ Ð²Ð¸Ñ€Ñ‚ÑƒÐ°Ð»ÑŒÐ½Ñ‹Ðµ ÑÐ²ÑÐ·Ð¸ parentâ†’child Ð¿Ð¾ Ñ‚Ð¸Ð¿Ð°Ð¼ Ð·Ð°Ð´Ð°Ñ‡ ÑÐ¾Ð³Ð»Ð°ÑÐ½Ð¾ LINK_HIERARCHY_RULES.
    """
    by_key = {i.get("key"): i for i in issues}

    def _g(obj, path: List[str]):
        for p in path:
            if obj is None:
                return None
            obj = obj.get(p) if isinstance(obj, dict) else None
        return obj

    # Ð¸Ð½Ð´ÐµÐºÑÑ‹
    children: Dict[str, List[str]] = {}
    epic_children: Dict[str, List[str]] = {}
    parent_map: Dict[str, Optional[str]] = {}
    epic_of: Dict[str, Optional[str]] = {}

    # ÑÐ²ÑÐ·Ð¸
    links_rows: List[dict] = []
    link_pairs: List[Tuple[str, str]] = []

    def issue_type_name(i: dict) -> str:
        return _g(i.get("fields", {}), ["issuetype", "name"]) or ""

    for k, it in by_key.items():
        fields = it.get("fields", {})
        parent = _g(fields, ["parent", "key"]) or None
        parent_map[k] = parent
        if parent:
            children.setdefault(parent, []).append(k)
        epic = fields.get(epic_link_field) if epic_link_field else None
        if isinstance(epic, dict):
            epic = epic.get("key")
        epic_of[k] = epic
        if epic:
            epic_children.setdefault(epic, []).append(k)
        for l in fields.get("issuelinks") or []:
            ltype = _g(l, ["type", "name"]) or ""
            inward = _g(l, ["inwardIssue", "key"]) or None
            outward = _g(l, ["outwardIssue", "key"]) or None
            if inward:
                links_rows.append({"From": k, "Direction": "inward", "Type": ltype, "To": inward})
                link_pairs.append((k, inward))
            if outward:
                links_rows.append({"From": k, "Direction": "outward", "Type": ltype, "To": outward})
                link_pairs.append((k, outward))

    if ENABLE_LINK_HIERARCHY and LINK_HIERARCHY_RULES:
        rules = [(a.lower(), b.lower()) for a, b in LINK_HIERARCHY_RULES]
        for a, b in link_pairs:
            ia = by_key.get(a); ib = by_key.get(b)
            if not ia or not ib:
                continue
            ta = issue_type_name(ia).lower(); tb = issue_type_name(ib).lower()
            if (ta, tb) in rules:
                if not parent_map.get(b) and not epic_of.get(b):
                    parent_map[b] = a
                    children.setdefault(a, []).append(b)
            if (tb, ta) in rules:
                if not parent_map.get(a) and not epic_of.get(a):
                    parent_map[a] = b
                    children.setdefault(b, []).append(a)

    epics = [k for k, it in by_key.items() if issue_type_name(it).lower() == "epic"]
    roots_wo_epic = [k for k, it in by_key.items() if (k not in epics and not parent_map.get(k) and not epic_of.get(k))]

    def row_from_key(key: str, level: int, rel_name: str) -> dict:
        it = by_key[key]
        f = it.get("fields", {})
        assignee = _g(f, ["assignee", "displayName"]) or ""
        status = _g(f, ["status", "name"]) or ""
        issue_type = issue_type_name(it)
        priority = _g(f, ["priority", "name"]) or ""
        created = _g(f, ["created"]) or ""
        updated = _g(f, ["updated"]) or ""
        summary = f.get("summary") or ""
        sp_raw = f.get(STORY_POINTS_FIELD_ID) if STORY_POINTS_FIELD_ID else None
        if isinstance(sp_raw, (int, float)):
            story_points = sp_raw
        else:
            try:
                story_points = float(sp_raw) if sp_raw is not None and str(sp_raw).strip() != "" else None
            except Exception:
                story_points = None
        fix_versions = ", ".join((v.get("name") for v in (f.get("fixVersions") or [])))
        epic_key = epic_of.get(key) or (key if issue_type.lower() == "epic" else None)
        parent_key = parent_map.get(key)
        return {
            "Release": rel_name,
            "Level": level,
            "ÐÐ¾Ð´Ð°": ("  " * level) + summary,
            "ÐšÐ»ÑŽÑ‡": key,
            "Ð¡ÑÑ‹Ð»ÐºÐ°": hyperlink_formula(key),
            "Ð¢Ð¸Ð¿": issue_type,
            "Ð¡Ñ‚Ð°Ñ‚ÑƒÑ": status,
            "Ð˜ÑÐ¿Ð¾Ð»Ð½Ð¸Ñ‚ÐµÐ»ÑŒ": assignee,
            "Story Points": story_points,
            "Epic": epic_key or "(Ð±ÐµÐ· ÑÐ¿Ð¸ÐºÐ°)",
            "Ð Ð¾Ð´Ð¸Ñ‚ÐµÐ»ÑŒ": parent_key or "",
            "Priority": priority,
            "Fix Version(s)": fix_versions,
            "Created": created,
            "Updated": updated,
        }

    rows: List[dict] = []

    def walk_issue(key: str, level: int):
        rows.append(row_from_key(key, level, release_name))
        for ch in children.get(key, []):
            walk_issue(ch, level + 1)

    for e in sorted(epics):
        rows.append(row_from_key(e, 0, release_name))
        for k in sorted(set(children.get(e, []) + epic_children.get(e, []))):
            walk_issue(k, 1)

    if roots_wo_epic:
        rows.append({
            "Release": release_name,
            "Level": 0,
            "ÐÐ¾Ð´Ð°": "(Ð±ÐµÐ· ÑÐ¿Ð¸ÐºÐ°)",
            "ÐšÐ»ÑŽÑ‡": "",
            "Ð¡ÑÑ‹Ð»ÐºÐ°": "",
            "Ð¢Ð¸Ð¿": "",
            "Ð¡Ñ‚Ð°Ñ‚ÑƒÑ": "",
            "Ð˜ÑÐ¿Ð¾Ð»Ð½Ð¸Ñ‚ÐµÐ»ÑŒ": "",
            "Story Points": None,
            "Epic": "(Ð±ÐµÐ· ÑÐ¿Ð¸ÐºÐ°)",
            "Ð Ð¾Ð´Ð¸Ñ‚ÐµÐ»ÑŒ": "",
            "Priority": "",
            "Fix Version(s)": "",
            "Created": "",
            "Updated": "",
        })
        for k in sorted(roots_wo_epic):
            walk_issue(k, 1)

    tree_df = pd.DataFrame(rows)
    links_df = pd.DataFrame(links_rows) if links_rows else pd.DataFrame(columns=["From","Direction","Type","To"])
    return tree_df, links_df

# ========= ÐžÑÐ½Ð¾Ð²Ð½Ð¾Ð¹ ÑÑ†ÐµÐ½Ð°Ñ€Ð¸Ð¹ =========

FIELDS_CACHE = None
EPIC_LINK_FIELD_ID = None
STORY_POINTS_FIELD_ID = None


def main():
    global FIELDS_CACHE, EPIC_LINK_FIELD_ID, STORY_POINTS_FIELD_ID

    # Ð”Ð¸Ð°Ð³Ð½Ð¾ÑÑ‚Ð¸ÐºÐ° Ð½Ð°ÑÑ‚Ñ€Ð¾ÐµÐº Ð¿ÐµÑ€ÐµÐ´ ÑÑ‚Ð°Ñ€Ñ‚Ð¾Ð¼ â€” ÑÑ€Ð°Ð·Ñƒ Ð²Ð¸Ð´Ð½Ð¾, Ñ‡Ñ‚Ð¾ Ð¼Ñ‹ Ñ€ÐµÐ°Ð»ÑŒÐ½Ð¾ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼
    print("=== Release Composer: ÑÑ‚Ð°Ñ€Ñ‚ ===")
    print(f"JIRA_URL        : {JIRA_URL}")
    print(f"PROJECT_KEY     : {PROJECT_KEY}")
    print(f"ONLY_UNRELEASED : {ONLY_UNRELEASED}")
    print(f"VERSIONS_FILTER : {', '.join(VERSIONS_FILTER) if VERSIONS_FILTER else '(Ð²ÑÐµ Ð¿Ð¾Ð´Ñ…Ð¾Ð´ÑÑ‰Ð¸Ðµ)'}")

    print("â†’ ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÑŽ ÑÐ¿Ð¸ÑÐ¾Ðº Ð²ÐµÑ€ÑÐ¸Ð¹...")
    versions = list_versions(PROJECT_KEY)
    if not versions:
        raise SystemExit("ÐÐµÑ‚ Ð¿Ð¾Ð´Ñ…Ð¾Ð´ÑÑ‰Ð¸Ñ… Ð²ÐµÑ€ÑÐ¸Ð¹ (Ð¿Ñ€Ð¾Ð²ÐµÑ€ÑŒ Ñ„Ð¸Ð»ÑŒÑ‚Ñ€Ñ‹/Ð¿Ñ€Ð°Ð²Ð°)")

    # ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»Ð¸Ð¼ id ÐºÐ°ÑÑ‚Ð¾Ð¼-Ð¿Ð¾Ð»ÐµÐ¹
    ids = get_field_ids()
    EPIC_LINK_FIELD_ID = ids.get("epic_link")
    STORY_POINTS_FIELD_ID = ids.get("story_points")
    if not EPIC_LINK_FIELD_ID:
        print("[warn] ÐÐµ Ð½Ð°ÑˆÑ‘Ð» id 'Epic Link' â€” Ð¸ÐµÑ€Ð°Ñ€Ñ…Ð¸Ñ Ð¼Ð¾Ð¶ÐµÑ‚ Ð±Ñ‹Ñ‚ÑŒ Ð½ÐµÐ¿Ð¾Ð»Ð½Ð¾Ð¹")

    fields = [
        "summary", "issuetype", "status", "assignee", "parent",
        "subtasks", "issuelinks", "priority", "fixVersions", "created", "updated",
    ]
    if EPIC_LINK_FIELD_ID:
        fields.append(EPIC_LINK_FIELD_ID)
    if STORY_POINTS_FIELD_ID:
        fields.append(STORY_POINTS_FIELD_ID)

    per_release = []
    overview_rows: List[pd.DataFrame] = []

    for v in versions:
        vname = v.get("name")
        print(f"â†’ Ð’ÐµÑ€ÑÐ¸Ñ: {vname}")
        jql = f'project={PROJECT_KEY} AND fixVersion="{vname}" ORDER BY issuetype, key'
        issues = jql_search(jql, fields, max_results=MAX_ISSUES)
        if not issues:
            print("  (Ð½ÐµÑ‚ Ð·Ð°Ð´Ð°Ñ‡)")
            continue
        tmp = []
        for it in issues:
            f = it.get("fields", {})
            tmp.append({
                "Release": vname,
                "Ð¢Ð¸Ð¿": (f.get("issuetype") or {}).get("name"),
                "Ð¡Ñ‚Ð°Ñ‚ÑƒÑ": (f.get("status") or {}).get("name"),
                "ÐšÐ»ÑŽÑ‡": it.get("key"),
            })
        ov = pd.DataFrame(tmp)
        overview_rows.append(ov)
        tree_df, links_df = flatten_release_tree(vname, issues, EPIC_LINK_FIELD_ID)
        tree_cols = [
            "Level","ÐÐ¾Ð´Ð°","Ð¡ÑÑ‹Ð»ÐºÐ°","Ð¢Ð¸Ð¿","Ð¡Ñ‚Ð°Ñ‚ÑƒÑ","Ð˜ÑÐ¿Ð¾Ð»Ð½Ð¸Ñ‚ÐµÐ»ÑŒ",
            "Story Points","Priority","Fix Version(s)","Created","Updated"
        ]
        tree_df = tree_df[tree_cols]
        per_release.append((vname, tree_df, links_df, ov))

    if not per_release:
        raise SystemExit("ÐÐµÑ‚ Ð·Ð°Ð´Ð°Ñ‡ Ð½Ð¸ Ð² Ð¾Ð´Ð½Ð¾Ð¹ Ð¸Ð· Ð¿Ð¾Ð´Ñ…Ð¾Ð´ÑÑ‰Ð¸Ñ… Ð²ÐµÑ€ÑÐ¸Ð¹")

    all_tree = pd.concat([tr for _, tr, _, _ in per_release], ignore_index=True)

    writer_path = OUT_DIR / f"release_composer_{PROJECT_KEY}_{datetime.now().strftime('%Y-%m-%d_%H-%M-%S')}.xlsx"
    with pd.ExcelWriter(writer_path, engine="openpyxl") as xw:
        # Ð¢Ð¾Ð»ÑŒÐºÐ¾ Tree-Ð²ÐºÐ»Ð°Ð´ÐºÐ¸ Ð¿Ð¾ ÐºÐ°Ð¶Ð´Ð¾Ð¹ Ð²ÐµÑ€ÑÐ¸Ð¸
        for vname, tree_df, links_df, _ov in per_release:
            sheet_tree = make_sheet_name(vname, "Tree")
            tree_df.to_excel(xw, index=False, sheet_name=sheet_tree)
            ws: Worksheet = xw.sheets[sheet_tree]
            for i in range(2, ws.max_row + 1):
                try:
                    level_val = tree_df.iloc[i - 2]["Level"] or 0
                except Exception:
                    level_val = 0
                ws.row_dimensions[i].outlineLevel = int(level_val)
            ws.sheet_properties.outlinePr.summaryBelow = True
            ws.sheet_properties.outlinePr.applyStyles = True
            ws.auto_filter.ref = ws.dimensions
            ws.freeze_panes = "A2"

        # Ð¡Ð²Ð¾Ð´Ð½Ð°Ñ Overview Ð¾ÑÑ‚Ð°Ð²Ð»ÑÐµÐ¼ (ÐµÑÐ»Ð¸ Ð½ÑƒÐ¶Ð½Ð° Ð°Ð½Ð°Ð»Ð¸Ñ‚Ð¸ÐºÐ°)
        if overview_rows:
            overview = pd.concat(overview_rows, ignore_index=True)
            pivot = pd.pivot_table(
                overview,
                index=["Release","Ð¢Ð¸Ð¿"],
                columns=["Ð¡Ñ‚Ð°Ñ‚ÑƒÑ"],
                values="ÐšÐ»ÑŽÑ‡",
                aggfunc="count",
                fill_value=0,
                margins=True,
            )
            pivot.to_excel(xw, sheet_name="Overview")
            ws_ov: Worksheet = xw.sheets["Overview"]
            ws_ov.auto_filter.ref = ws_ov.dimensions
            ws_ov.freeze_panes = "A2"

    # ÐÐ²Ñ‚Ð¾Ñ„Ð¸Ñ‚ ÑˆÐ¸Ñ€Ð¸Ð½Ñ‹ Ð²ÑÐµÑ… Ð»Ð¸ÑÑ‚Ð¾Ð²
    excel_autofit_smart(writer_path, width_overrides={
        "ÐÐ¾Ð´Ð°": 60,
        "Ð¡ÑÑ‹Ð»ÐºÐ°": 16,
        "Ð˜ÑÐ¿Ð¾Ð»Ð½Ð¸Ñ‚ÐµÐ»ÑŒ": 28,
        "Fix Version(s)": 28,
        "Priority": 12,
    })

    print(f"Ð“Ð¾Ñ‚Ð¾Ð²Ð¾ â†’ {writer_path}")


if __name__ == "__main__":
    # ÐŸÐ¾Ð´Ð´ÐµÑ€Ð¶ÐºÐ° Ð·Ð°Ð¿ÑƒÑÐºÐ° Ð¸Ð· ÐºÐ¾Ð½ÑÐ¾Ð»Ð¸ Ñ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð°Ð¼Ð¸: python Release.py CSHRM "Rel 2025.10"
    import sys
    if len(sys.argv) >= 2:
        pk = sys.argv[1].strip()
        if pk:
            PROJECT_KEY = pk
    if len(sys.argv) >= 3:
        VERSIONS_FILTER = [sys.argv[2].strip()]
    main()
